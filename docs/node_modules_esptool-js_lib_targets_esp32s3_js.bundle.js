"use strict";
(self["webpackChunkTactility_Web_Installer"] = self["webpackChunkTactility_Web_Installer"] || []).push([["node_modules_esptool-js_lib_targets_esp32s3_js"],{

/***/ "./node_modules/esptool-js/lib/targets/esp32s3.js":
/*!********************************************************!*\
  !*** ./node_modules/esptool-js/lib/targets/esp32s3.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ESP32S3ROM: () => (/* binding */ ESP32S3ROM)
/* harmony export */ });
/* harmony import */ var _rom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rom.js */ "./node_modules/esptool-js/lib/targets/rom.js");

class ESP32S3ROM extends _rom_js__WEBPACK_IMPORTED_MODULE_0__.ROM {
    constructor() {
        super(...arguments);
        this.CHIP_NAME = "ESP32-S3";
        this.IMAGE_CHIP_ID = 9;
        this.EFUSE_BASE = 0x60007000;
        this.MAC_EFUSE_REG = this.EFUSE_BASE + 0x044;
        this.EFUSE_BLOCK1_ADDR = this.EFUSE_BASE + 0x44;
        this.EFUSE_BLOCK2_ADDR = this.EFUSE_BASE + 0x5c;
        this.UART_CLKDIV_REG = 0x60000014;
        this.UART_CLKDIV_MASK = 0xfffff;
        this.UART_DATE_REG_ADDR = 0x60000080;
        this.FLASH_WRITE_SIZE = 0x400;
        this.BOOTLOADER_FLASH_OFFSET = 0x0;
        this.FLASH_SIZES = {
            "1MB": 0x00,
            "2MB": 0x10,
            "4MB": 0x20,
            "8MB": 0x30,
            "16MB": 0x40,
        };
        this.SPI_REG_BASE = 0x60002000;
        this.SPI_USR_OFFS = 0x18;
        this.SPI_USR1_OFFS = 0x1c;
        this.SPI_USR2_OFFS = 0x20;
        this.SPI_MOSI_DLEN_OFFS = 0x24;
        this.SPI_MISO_DLEN_OFFS = 0x28;
        this.SPI_W0_OFFS = 0x58;
        this.USB_RAM_BLOCK = 0x800;
        this.UARTDEV_BUF_NO_USB = 3;
        this.UARTDEV_BUF_NO = 0x3fcef14c;
    }
    async getChipDescription(loader) {
        const majorRev = await this.getMajorChipVersion(loader);
        const minorRev = await this.getMinorChipVersion(loader);
        const pkgVersion = await this.getPkgVersion(loader);
        const chipName = {
            0: "ESP32-S3 (QFN56)",
            1: "ESP32-S3-PICO-1 (LGA56)",
        };
        return `${chipName[pkgVersion] || "unknown ESP32-S3"} (revision v${majorRev}.${minorRev})`;
    }
    async getPkgVersion(loader) {
        const numWord = 3;
        return ((await loader.readReg(this.EFUSE_BLOCK1_ADDR + 4 * numWord)) >> 21) & 0x07;
    }
    async getRawMinorChipVersion(loader) {
        const hiNumWord = 5;
        const hi = ((await loader.readReg(this.EFUSE_BLOCK1_ADDR + 4 * hiNumWord)) >> 23) & 0x01;
        const lowNumWord = 3;
        const low = ((await loader.readReg(this.EFUSE_BLOCK1_ADDR + 4 * lowNumWord)) >> 18) & 0x07;
        return (hi << 3) + low;
    }
    async getMinorChipVersion(loader) {
        const minorRaw = await this.getRawMinorChipVersion(loader);
        if (await this.isEco0(loader, minorRaw)) {
            return 0;
        }
        return this.getRawMinorChipVersion(loader);
    }
    async getRawMajorChipVersion(loader) {
        const numWord = 5;
        return ((await loader.readReg(this.EFUSE_BLOCK1_ADDR + 4 * numWord)) >> 24) & 0x03;
    }
    async getMajorChipVersion(loader) {
        const minorRaw = await this.getRawMinorChipVersion(loader);
        if (await this.isEco0(loader, minorRaw)) {
            return 0;
        }
        return this.getRawMajorChipVersion(loader);
    }
    async getBlkVersionMajor(loader) {
        const numWord = 4;
        return ((await loader.readReg(this.EFUSE_BLOCK2_ADDR + 4 * numWord)) >> 0) & 0x03;
    }
    async getBlkVersionMinor(loader) {
        const numWord = 3;
        return ((await loader.readReg(this.EFUSE_BLOCK1_ADDR + 4 * numWord)) >> 24) & 0x07;
    }
    async isEco0(loader, minorRaw) {
        // Workaround: The major version field was allocated to other purposes
        // when block version is v1.1.
        // Luckily only chip v0.0 have this kind of block version and efuse usage.
        return ((minorRaw & 0x7) === 0 &&
            (await this.getBlkVersionMajor(loader)) === 1 &&
            (await this.getBlkVersionMinor(loader)) === 1);
    }
    async getFlashCap(loader) {
        const numWord = 3;
        const block1Addr = this.EFUSE_BASE + 0x044;
        const addr = block1Addr + 4 * numWord;
        const registerValue = await loader.readReg(addr);
        const flashCap = (registerValue >> 27) & 0x07;
        return flashCap;
    }
    async getFlashVendor(loader) {
        const numWord = 4;
        const block1Addr = this.EFUSE_BASE + 0x044;
        const addr = block1Addr + 4 * numWord;
        const registerValue = await loader.readReg(addr);
        const vendorId = (registerValue >> 0) & 0x07;
        const vendorMap = {
            1: "XMC",
            2: "GD",
            3: "FM",
            4: "TT",
            5: "BY",
        };
        return vendorMap[vendorId] || "";
    }
    async getPsramCap(loader) {
        const numWord = 4;
        const block1Addr = this.EFUSE_BASE + 0x044;
        const addr = block1Addr + 4 * numWord;
        const registerValue = await loader.readReg(addr);
        const psramCap = (registerValue >> 3) & 0x03;
        return psramCap;
    }
    async getPsramVendor(loader) {
        const numWord = 4;
        const block1Addr = this.EFUSE_BASE + 0x044;
        const addr = block1Addr + 4 * numWord;
        const registerValue = await loader.readReg(addr);
        const vendorId = (registerValue >> 7) & 0x03;
        const vendorMap = {
            1: "AP_3v3",
            2: "AP_1v8",
        };
        return vendorMap[vendorId] || "";
    }
    async getChipFeatures(loader) {
        const features = ["Wi-Fi", "BLE"];
        const flashMap = {
            0: null,
            1: "Embedded Flash 8MB",
            2: "Embedded Flash 4MB",
        };
        const flashCap = await this.getFlashCap(loader);
        const flashVendor = await this.getFlashVendor(loader);
        const flash = flashMap[flashCap];
        const flashDescription = flash !== undefined ? flash : "Unknown Embedded Flash";
        if (flash !== null) {
            features.push(`${flashDescription} (${flashVendor})`);
        }
        const psramMap = {
            0: null,
            1: "Embedded PSRAM 8MB",
            2: "Embedded PSRAM 2MB",
        };
        const psramCap = await this.getPsramCap(loader);
        const psramVendor = await this.getPsramVendor(loader);
        const psram = psramMap[psramCap];
        const psramDescription = psram !== undefined ? psram : "Unknown Embedded PSRAM";
        if (psram !== null) {
            features.push(`${psramDescription} (${psramVendor})`);
        }
        return features;
    }
    async getCrystalFreq(loader) {
        return 40;
    }
    _d2h(d) {
        const h = (+d).toString(16);
        return h.length === 1 ? "0" + h : h;
    }
    async postConnect(loader) {
        const bufNo = (await loader.readReg(this.UARTDEV_BUF_NO)) & 0xff;
        loader.debug("In _post_connect " + bufNo);
        if (bufNo == this.UARTDEV_BUF_NO_USB) {
            loader.ESP_RAM_BLOCK = this.USB_RAM_BLOCK;
        }
    }
    async readMac(loader) {
        let mac0 = await loader.readReg(this.MAC_EFUSE_REG);
        mac0 = mac0 >>> 0;
        let mac1 = await loader.readReg(this.MAC_EFUSE_REG + 4);
        mac1 = (mac1 >>> 0) & 0x0000ffff;
        const mac = new Uint8Array(6);
        mac[0] = (mac1 >> 8) & 0xff;
        mac[1] = mac1 & 0xff;
        mac[2] = (mac0 >> 24) & 0xff;
        mac[3] = (mac0 >> 16) & 0xff;
        mac[4] = (mac0 >> 8) & 0xff;
        mac[5] = mac0 & 0xff;
        return (this._d2h(mac[0]) +
            ":" +
            this._d2h(mac[1]) +
            ":" +
            this._d2h(mac[2]) +
            ":" +
            this._d2h(mac[3]) +
            ":" +
            this._d2h(mac[4]) +
            ":" +
            this._d2h(mac[5]));
    }
    getEraseSize(offset, size) {
        return size;
    }
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2VzcHRvb2wtanNfbGliX3RhcmdldHNfZXNwMzJzM19qcy5idW5kbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBK0I7QUFDeEIseUJBQXlCLHdDQUFHO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0Q0FBNEMsYUFBYSxTQUFTLEdBQUcsU0FBUztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtCQUFrQixHQUFHLFlBQVk7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrQkFBa0IsR0FBRyxZQUFZO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL1RhY3RpbGl0eSBXZWIgSW5zdGFsbGVyLy4vbm9kZV9tb2R1bGVzL2VzcHRvb2wtanMvbGliL3RhcmdldHMvZXNwMzJzMy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBST00gfSBmcm9tIFwiLi9yb20uanNcIjtcbmV4cG9ydCBjbGFzcyBFU1AzMlMzUk9NIGV4dGVuZHMgUk9NIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5DSElQX05BTUUgPSBcIkVTUDMyLVMzXCI7XG4gICAgICAgIHRoaXMuSU1BR0VfQ0hJUF9JRCA9IDk7XG4gICAgICAgIHRoaXMuRUZVU0VfQkFTRSA9IDB4NjAwMDcwMDA7XG4gICAgICAgIHRoaXMuTUFDX0VGVVNFX1JFRyA9IHRoaXMuRUZVU0VfQkFTRSArIDB4MDQ0O1xuICAgICAgICB0aGlzLkVGVVNFX0JMT0NLMV9BRERSID0gdGhpcy5FRlVTRV9CQVNFICsgMHg0NDtcbiAgICAgICAgdGhpcy5FRlVTRV9CTE9DSzJfQUREUiA9IHRoaXMuRUZVU0VfQkFTRSArIDB4NWM7XG4gICAgICAgIHRoaXMuVUFSVF9DTEtESVZfUkVHID0gMHg2MDAwMDAxNDtcbiAgICAgICAgdGhpcy5VQVJUX0NMS0RJVl9NQVNLID0gMHhmZmZmZjtcbiAgICAgICAgdGhpcy5VQVJUX0RBVEVfUkVHX0FERFIgPSAweDYwMDAwMDgwO1xuICAgICAgICB0aGlzLkZMQVNIX1dSSVRFX1NJWkUgPSAweDQwMDtcbiAgICAgICAgdGhpcy5CT09UTE9BREVSX0ZMQVNIX09GRlNFVCA9IDB4MDtcbiAgICAgICAgdGhpcy5GTEFTSF9TSVpFUyA9IHtcbiAgICAgICAgICAgIFwiMU1CXCI6IDB4MDAsXG4gICAgICAgICAgICBcIjJNQlwiOiAweDEwLFxuICAgICAgICAgICAgXCI0TUJcIjogMHgyMCxcbiAgICAgICAgICAgIFwiOE1CXCI6IDB4MzAsXG4gICAgICAgICAgICBcIjE2TUJcIjogMHg0MCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5TUElfUkVHX0JBU0UgPSAweDYwMDAyMDAwO1xuICAgICAgICB0aGlzLlNQSV9VU1JfT0ZGUyA9IDB4MTg7XG4gICAgICAgIHRoaXMuU1BJX1VTUjFfT0ZGUyA9IDB4MWM7XG4gICAgICAgIHRoaXMuU1BJX1VTUjJfT0ZGUyA9IDB4MjA7XG4gICAgICAgIHRoaXMuU1BJX01PU0lfRExFTl9PRkZTID0gMHgyNDtcbiAgICAgICAgdGhpcy5TUElfTUlTT19ETEVOX09GRlMgPSAweDI4O1xuICAgICAgICB0aGlzLlNQSV9XMF9PRkZTID0gMHg1ODtcbiAgICAgICAgdGhpcy5VU0JfUkFNX0JMT0NLID0gMHg4MDA7XG4gICAgICAgIHRoaXMuVUFSVERFVl9CVUZfTk9fVVNCID0gMztcbiAgICAgICAgdGhpcy5VQVJUREVWX0JVRl9OTyA9IDB4M2ZjZWYxNGM7XG4gICAgfVxuICAgIGFzeW5jIGdldENoaXBEZXNjcmlwdGlvbihsb2FkZXIpIHtcbiAgICAgICAgY29uc3QgbWFqb3JSZXYgPSBhd2FpdCB0aGlzLmdldE1ham9yQ2hpcFZlcnNpb24obG9hZGVyKTtcbiAgICAgICAgY29uc3QgbWlub3JSZXYgPSBhd2FpdCB0aGlzLmdldE1pbm9yQ2hpcFZlcnNpb24obG9hZGVyKTtcbiAgICAgICAgY29uc3QgcGtnVmVyc2lvbiA9IGF3YWl0IHRoaXMuZ2V0UGtnVmVyc2lvbihsb2FkZXIpO1xuICAgICAgICBjb25zdCBjaGlwTmFtZSA9IHtcbiAgICAgICAgICAgIDA6IFwiRVNQMzItUzMgKFFGTjU2KVwiLFxuICAgICAgICAgICAgMTogXCJFU1AzMi1TMy1QSUNPLTEgKExHQTU2KVwiLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYCR7Y2hpcE5hbWVbcGtnVmVyc2lvbl0gfHwgXCJ1bmtub3duIEVTUDMyLVMzXCJ9IChyZXZpc2lvbiB2JHttYWpvclJldn0uJHttaW5vclJldn0pYDtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UGtnVmVyc2lvbihsb2FkZXIpIHtcbiAgICAgICAgY29uc3QgbnVtV29yZCA9IDM7XG4gICAgICAgIHJldHVybiAoKGF3YWl0IGxvYWRlci5yZWFkUmVnKHRoaXMuRUZVU0VfQkxPQ0sxX0FERFIgKyA0ICogbnVtV29yZCkpID4+IDIxKSAmIDB4MDc7XG4gICAgfVxuICAgIGFzeW5jIGdldFJhd01pbm9yQ2hpcFZlcnNpb24obG9hZGVyKSB7XG4gICAgICAgIGNvbnN0IGhpTnVtV29yZCA9IDU7XG4gICAgICAgIGNvbnN0IGhpID0gKChhd2FpdCBsb2FkZXIucmVhZFJlZyh0aGlzLkVGVVNFX0JMT0NLMV9BRERSICsgNCAqIGhpTnVtV29yZCkpID4+IDIzKSAmIDB4MDE7XG4gICAgICAgIGNvbnN0IGxvd051bVdvcmQgPSAzO1xuICAgICAgICBjb25zdCBsb3cgPSAoKGF3YWl0IGxvYWRlci5yZWFkUmVnKHRoaXMuRUZVU0VfQkxPQ0sxX0FERFIgKyA0ICogbG93TnVtV29yZCkpID4+IDE4KSAmIDB4MDc7XG4gICAgICAgIHJldHVybiAoaGkgPDwgMykgKyBsb3c7XG4gICAgfVxuICAgIGFzeW5jIGdldE1pbm9yQ2hpcFZlcnNpb24obG9hZGVyKSB7XG4gICAgICAgIGNvbnN0IG1pbm9yUmF3ID0gYXdhaXQgdGhpcy5nZXRSYXdNaW5vckNoaXBWZXJzaW9uKGxvYWRlcik7XG4gICAgICAgIGlmIChhd2FpdCB0aGlzLmlzRWNvMChsb2FkZXIsIG1pbm9yUmF3KSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmF3TWlub3JDaGlwVmVyc2lvbihsb2FkZXIpO1xuICAgIH1cbiAgICBhc3luYyBnZXRSYXdNYWpvckNoaXBWZXJzaW9uKGxvYWRlcikge1xuICAgICAgICBjb25zdCBudW1Xb3JkID0gNTtcbiAgICAgICAgcmV0dXJuICgoYXdhaXQgbG9hZGVyLnJlYWRSZWcodGhpcy5FRlVTRV9CTE9DSzFfQUREUiArIDQgKiBudW1Xb3JkKSkgPj4gMjQpICYgMHgwMztcbiAgICB9XG4gICAgYXN5bmMgZ2V0TWFqb3JDaGlwVmVyc2lvbihsb2FkZXIpIHtcbiAgICAgICAgY29uc3QgbWlub3JSYXcgPSBhd2FpdCB0aGlzLmdldFJhd01pbm9yQ2hpcFZlcnNpb24obG9hZGVyKTtcbiAgICAgICAgaWYgKGF3YWl0IHRoaXMuaXNFY28wKGxvYWRlciwgbWlub3JSYXcpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRSYXdNYWpvckNoaXBWZXJzaW9uKGxvYWRlcik7XG4gICAgfVxuICAgIGFzeW5jIGdldEJsa1ZlcnNpb25NYWpvcihsb2FkZXIpIHtcbiAgICAgICAgY29uc3QgbnVtV29yZCA9IDQ7XG4gICAgICAgIHJldHVybiAoKGF3YWl0IGxvYWRlci5yZWFkUmVnKHRoaXMuRUZVU0VfQkxPQ0syX0FERFIgKyA0ICogbnVtV29yZCkpID4+IDApICYgMHgwMztcbiAgICB9XG4gICAgYXN5bmMgZ2V0QmxrVmVyc2lvbk1pbm9yKGxvYWRlcikge1xuICAgICAgICBjb25zdCBudW1Xb3JkID0gMztcbiAgICAgICAgcmV0dXJuICgoYXdhaXQgbG9hZGVyLnJlYWRSZWcodGhpcy5FRlVTRV9CTE9DSzFfQUREUiArIDQgKiBudW1Xb3JkKSkgPj4gMjQpICYgMHgwNztcbiAgICB9XG4gICAgYXN5bmMgaXNFY28wKGxvYWRlciwgbWlub3JSYXcpIHtcbiAgICAgICAgLy8gV29ya2Fyb3VuZDogVGhlIG1ham9yIHZlcnNpb24gZmllbGQgd2FzIGFsbG9jYXRlZCB0byBvdGhlciBwdXJwb3Nlc1xuICAgICAgICAvLyB3aGVuIGJsb2NrIHZlcnNpb24gaXMgdjEuMS5cbiAgICAgICAgLy8gTHVja2lseSBvbmx5IGNoaXAgdjAuMCBoYXZlIHRoaXMga2luZCBvZiBibG9jayB2ZXJzaW9uIGFuZCBlZnVzZSB1c2FnZS5cbiAgICAgICAgcmV0dXJuICgobWlub3JSYXcgJiAweDcpID09PSAwICYmXG4gICAgICAgICAgICAoYXdhaXQgdGhpcy5nZXRCbGtWZXJzaW9uTWFqb3IobG9hZGVyKSkgPT09IDEgJiZcbiAgICAgICAgICAgIChhd2FpdCB0aGlzLmdldEJsa1ZlcnNpb25NaW5vcihsb2FkZXIpKSA9PT0gMSk7XG4gICAgfVxuICAgIGFzeW5jIGdldEZsYXNoQ2FwKGxvYWRlcikge1xuICAgICAgICBjb25zdCBudW1Xb3JkID0gMztcbiAgICAgICAgY29uc3QgYmxvY2sxQWRkciA9IHRoaXMuRUZVU0VfQkFTRSArIDB4MDQ0O1xuICAgICAgICBjb25zdCBhZGRyID0gYmxvY2sxQWRkciArIDQgKiBudW1Xb3JkO1xuICAgICAgICBjb25zdCByZWdpc3RlclZhbHVlID0gYXdhaXQgbG9hZGVyLnJlYWRSZWcoYWRkcik7XG4gICAgICAgIGNvbnN0IGZsYXNoQ2FwID0gKHJlZ2lzdGVyVmFsdWUgPj4gMjcpICYgMHgwNztcbiAgICAgICAgcmV0dXJuIGZsYXNoQ2FwO1xuICAgIH1cbiAgICBhc3luYyBnZXRGbGFzaFZlbmRvcihsb2FkZXIpIHtcbiAgICAgICAgY29uc3QgbnVtV29yZCA9IDQ7XG4gICAgICAgIGNvbnN0IGJsb2NrMUFkZHIgPSB0aGlzLkVGVVNFX0JBU0UgKyAweDA0NDtcbiAgICAgICAgY29uc3QgYWRkciA9IGJsb2NrMUFkZHIgKyA0ICogbnVtV29yZDtcbiAgICAgICAgY29uc3QgcmVnaXN0ZXJWYWx1ZSA9IGF3YWl0IGxvYWRlci5yZWFkUmVnKGFkZHIpO1xuICAgICAgICBjb25zdCB2ZW5kb3JJZCA9IChyZWdpc3RlclZhbHVlID4+IDApICYgMHgwNztcbiAgICAgICAgY29uc3QgdmVuZG9yTWFwID0ge1xuICAgICAgICAgICAgMTogXCJYTUNcIixcbiAgICAgICAgICAgIDI6IFwiR0RcIixcbiAgICAgICAgICAgIDM6IFwiRk1cIixcbiAgICAgICAgICAgIDQ6IFwiVFRcIixcbiAgICAgICAgICAgIDU6IFwiQllcIixcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHZlbmRvck1hcFt2ZW5kb3JJZF0gfHwgXCJcIjtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UHNyYW1DYXAobG9hZGVyKSB7XG4gICAgICAgIGNvbnN0IG51bVdvcmQgPSA0O1xuICAgICAgICBjb25zdCBibG9jazFBZGRyID0gdGhpcy5FRlVTRV9CQVNFICsgMHgwNDQ7XG4gICAgICAgIGNvbnN0IGFkZHIgPSBibG9jazFBZGRyICsgNCAqIG51bVdvcmQ7XG4gICAgICAgIGNvbnN0IHJlZ2lzdGVyVmFsdWUgPSBhd2FpdCBsb2FkZXIucmVhZFJlZyhhZGRyKTtcbiAgICAgICAgY29uc3QgcHNyYW1DYXAgPSAocmVnaXN0ZXJWYWx1ZSA+PiAzKSAmIDB4MDM7XG4gICAgICAgIHJldHVybiBwc3JhbUNhcDtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UHNyYW1WZW5kb3IobG9hZGVyKSB7XG4gICAgICAgIGNvbnN0IG51bVdvcmQgPSA0O1xuICAgICAgICBjb25zdCBibG9jazFBZGRyID0gdGhpcy5FRlVTRV9CQVNFICsgMHgwNDQ7XG4gICAgICAgIGNvbnN0IGFkZHIgPSBibG9jazFBZGRyICsgNCAqIG51bVdvcmQ7XG4gICAgICAgIGNvbnN0IHJlZ2lzdGVyVmFsdWUgPSBhd2FpdCBsb2FkZXIucmVhZFJlZyhhZGRyKTtcbiAgICAgICAgY29uc3QgdmVuZG9ySWQgPSAocmVnaXN0ZXJWYWx1ZSA+PiA3KSAmIDB4MDM7XG4gICAgICAgIGNvbnN0IHZlbmRvck1hcCA9IHtcbiAgICAgICAgICAgIDE6IFwiQVBfM3YzXCIsXG4gICAgICAgICAgICAyOiBcIkFQXzF2OFwiLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdmVuZG9yTWFwW3ZlbmRvcklkXSB8fCBcIlwiO1xuICAgIH1cbiAgICBhc3luYyBnZXRDaGlwRmVhdHVyZXMobG9hZGVyKSB7XG4gICAgICAgIGNvbnN0IGZlYXR1cmVzID0gW1wiV2ktRmlcIiwgXCJCTEVcIl07XG4gICAgICAgIGNvbnN0IGZsYXNoTWFwID0ge1xuICAgICAgICAgICAgMDogbnVsbCxcbiAgICAgICAgICAgIDE6IFwiRW1iZWRkZWQgRmxhc2ggOE1CXCIsXG4gICAgICAgICAgICAyOiBcIkVtYmVkZGVkIEZsYXNoIDRNQlwiLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBmbGFzaENhcCA9IGF3YWl0IHRoaXMuZ2V0Rmxhc2hDYXAobG9hZGVyKTtcbiAgICAgICAgY29uc3QgZmxhc2hWZW5kb3IgPSBhd2FpdCB0aGlzLmdldEZsYXNoVmVuZG9yKGxvYWRlcik7XG4gICAgICAgIGNvbnN0IGZsYXNoID0gZmxhc2hNYXBbZmxhc2hDYXBdO1xuICAgICAgICBjb25zdCBmbGFzaERlc2NyaXB0aW9uID0gZmxhc2ggIT09IHVuZGVmaW5lZCA/IGZsYXNoIDogXCJVbmtub3duIEVtYmVkZGVkIEZsYXNoXCI7XG4gICAgICAgIGlmIChmbGFzaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZmVhdHVyZXMucHVzaChgJHtmbGFzaERlc2NyaXB0aW9ufSAoJHtmbGFzaFZlbmRvcn0pYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHNyYW1NYXAgPSB7XG4gICAgICAgICAgICAwOiBudWxsLFxuICAgICAgICAgICAgMTogXCJFbWJlZGRlZCBQU1JBTSA4TUJcIixcbiAgICAgICAgICAgIDI6IFwiRW1iZWRkZWQgUFNSQU0gMk1CXCIsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHBzcmFtQ2FwID0gYXdhaXQgdGhpcy5nZXRQc3JhbUNhcChsb2FkZXIpO1xuICAgICAgICBjb25zdCBwc3JhbVZlbmRvciA9IGF3YWl0IHRoaXMuZ2V0UHNyYW1WZW5kb3IobG9hZGVyKTtcbiAgICAgICAgY29uc3QgcHNyYW0gPSBwc3JhbU1hcFtwc3JhbUNhcF07XG4gICAgICAgIGNvbnN0IHBzcmFtRGVzY3JpcHRpb24gPSBwc3JhbSAhPT0gdW5kZWZpbmVkID8gcHNyYW0gOiBcIlVua25vd24gRW1iZWRkZWQgUFNSQU1cIjtcbiAgICAgICAgaWYgKHBzcmFtICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmZWF0dXJlcy5wdXNoKGAke3BzcmFtRGVzY3JpcHRpb259ICgke3BzcmFtVmVuZG9yfSlgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmVhdHVyZXM7XG4gICAgfVxuICAgIGFzeW5jIGdldENyeXN0YWxGcmVxKGxvYWRlcikge1xuICAgICAgICByZXR1cm4gNDA7XG4gICAgfVxuICAgIF9kMmgoZCkge1xuICAgICAgICBjb25zdCBoID0gKCtkKS50b1N0cmluZygxNik7XG4gICAgICAgIHJldHVybiBoLmxlbmd0aCA9PT0gMSA/IFwiMFwiICsgaCA6IGg7XG4gICAgfVxuICAgIGFzeW5jIHBvc3RDb25uZWN0KGxvYWRlcikge1xuICAgICAgICBjb25zdCBidWZObyA9IChhd2FpdCBsb2FkZXIucmVhZFJlZyh0aGlzLlVBUlRERVZfQlVGX05PKSkgJiAweGZmO1xuICAgICAgICBsb2FkZXIuZGVidWcoXCJJbiBfcG9zdF9jb25uZWN0IFwiICsgYnVmTm8pO1xuICAgICAgICBpZiAoYnVmTm8gPT0gdGhpcy5VQVJUREVWX0JVRl9OT19VU0IpIHtcbiAgICAgICAgICAgIGxvYWRlci5FU1BfUkFNX0JMT0NLID0gdGhpcy5VU0JfUkFNX0JMT0NLO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHJlYWRNYWMobG9hZGVyKSB7XG4gICAgICAgIGxldCBtYWMwID0gYXdhaXQgbG9hZGVyLnJlYWRSZWcodGhpcy5NQUNfRUZVU0VfUkVHKTtcbiAgICAgICAgbWFjMCA9IG1hYzAgPj4+IDA7XG4gICAgICAgIGxldCBtYWMxID0gYXdhaXQgbG9hZGVyLnJlYWRSZWcodGhpcy5NQUNfRUZVU0VfUkVHICsgNCk7XG4gICAgICAgIG1hYzEgPSAobWFjMSA+Pj4gMCkgJiAweDAwMDBmZmZmO1xuICAgICAgICBjb25zdCBtYWMgPSBuZXcgVWludDhBcnJheSg2KTtcbiAgICAgICAgbWFjWzBdID0gKG1hYzEgPj4gOCkgJiAweGZmO1xuICAgICAgICBtYWNbMV0gPSBtYWMxICYgMHhmZjtcbiAgICAgICAgbWFjWzJdID0gKG1hYzAgPj4gMjQpICYgMHhmZjtcbiAgICAgICAgbWFjWzNdID0gKG1hYzAgPj4gMTYpICYgMHhmZjtcbiAgICAgICAgbWFjWzRdID0gKG1hYzAgPj4gOCkgJiAweGZmO1xuICAgICAgICBtYWNbNV0gPSBtYWMwICYgMHhmZjtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9kMmgobWFjWzBdKSArXG4gICAgICAgICAgICBcIjpcIiArXG4gICAgICAgICAgICB0aGlzLl9kMmgobWFjWzFdKSArXG4gICAgICAgICAgICBcIjpcIiArXG4gICAgICAgICAgICB0aGlzLl9kMmgobWFjWzJdKSArXG4gICAgICAgICAgICBcIjpcIiArXG4gICAgICAgICAgICB0aGlzLl9kMmgobWFjWzNdKSArXG4gICAgICAgICAgICBcIjpcIiArXG4gICAgICAgICAgICB0aGlzLl9kMmgobWFjWzRdKSArXG4gICAgICAgICAgICBcIjpcIiArXG4gICAgICAgICAgICB0aGlzLl9kMmgobWFjWzVdKSk7XG4gICAgfVxuICAgIGdldEVyYXNlU2l6ZShvZmZzZXQsIHNpemUpIHtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9