"use strict";
(self["webpackChunkTactility_Web_Installer"] = self["webpackChunkTactility_Web_Installer"] || []).push([["vendors-node_modules_esptool-js_lib_targets_esp32p4_js"],{

/***/ "./node_modules/esptool-js/lib/targets/esp32.js":
/*!******************************************************!*\
  !*** ./node_modules/esptool-js/lib/targets/esp32.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ESP32ROM: () => (/* binding */ ESP32ROM)
/* harmony export */ });
/* harmony import */ var _rom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rom.js */ "./node_modules/esptool-js/lib/targets/rom.js");

class ESP32ROM extends _rom_js__WEBPACK_IMPORTED_MODULE_0__.ROM {
    constructor() {
        super(...arguments);
        this.CHIP_NAME = "ESP32";
        this.IMAGE_CHIP_ID = 0;
        this.EFUSE_RD_REG_BASE = 0x3ff5a000;
        this.DR_REG_SYSCON_BASE = 0x3ff66000;
        this.UART_CLKDIV_REG = 0x3ff40014;
        this.UART_CLKDIV_MASK = 0xfffff;
        this.UART_DATE_REG_ADDR = 0x60000078;
        this.XTAL_CLK_DIVIDER = 1;
        this.FLASH_SIZES = {
            "1MB": 0x00,
            "2MB": 0x10,
            "4MB": 0x20,
            "8MB": 0x30,
            "16MB": 0x40,
        };
        this.FLASH_WRITE_SIZE = 0x400;
        this.BOOTLOADER_FLASH_OFFSET = 0x1000;
        this.SPI_REG_BASE = 0x3ff42000;
        this.SPI_USR_OFFS = 0x1c;
        this.SPI_USR1_OFFS = 0x20;
        this.SPI_USR2_OFFS = 0x24;
        this.SPI_W0_OFFS = 0x80;
        this.SPI_MOSI_DLEN_OFFS = 0x28;
        this.SPI_MISO_DLEN_OFFS = 0x2c;
    }
    async readEfuse(loader, offset) {
        const addr = this.EFUSE_RD_REG_BASE + 4 * offset;
        loader.debug("Read efuse " + addr);
        return await loader.readReg(addr);
    }
    async getPkgVersion(loader) {
        const word3 = await this.readEfuse(loader, 3);
        let pkgVersion = (word3 >> 9) & 0x07;
        pkgVersion += ((word3 >> 2) & 0x1) << 3;
        return pkgVersion;
    }
    async getChipRevision(loader) {
        const word3 = await this.readEfuse(loader, 3);
        const word5 = await this.readEfuse(loader, 5);
        const apbCtlDate = await loader.readReg(this.DR_REG_SYSCON_BASE + 0x7c);
        const revBit0 = (word3 >> 15) & 0x1;
        const revBit1 = (word5 >> 20) & 0x1;
        const revBit2 = (apbCtlDate >> 31) & 0x1;
        if (revBit0 != 0) {
            if (revBit1 != 0) {
                if (revBit2 != 0) {
                    return 3;
                }
                else {
                    return 2;
                }
            }
            else {
                return 1;
            }
        }
        return 0;
    }
    async getChipDescription(loader) {
        const chipDesc = [
            "ESP32-D0WDQ6",
            "ESP32-D0WD",
            "ESP32-D2WD",
            "",
            "ESP32-U4WDH",
            "ESP32-PICO-D4",
            "ESP32-PICO-V3-02",
        ];
        let chipName = "";
        const pkgVersion = await this.getPkgVersion(loader);
        const chipRevision = await this.getChipRevision(loader);
        const rev3 = chipRevision == 3;
        const single_core = (await this.readEfuse(loader, 3)) & (1 << 0);
        if (single_core != 0) {
            chipDesc[0] = "ESP32-S0WDQ6";
            chipDesc[1] = "ESP32-S0WD";
        }
        if (rev3) {
            chipDesc[5] = "ESP32-PICO-V3";
        }
        if (pkgVersion >= 0 && pkgVersion <= 6) {
            chipName = chipDesc[pkgVersion];
        }
        else {
            chipName = "Unknown ESP32";
        }
        if (rev3 && (pkgVersion === 0 || pkgVersion === 1)) {
            chipName += "-V3";
        }
        return chipName + " (revision " + chipRevision + ")";
    }
    async getChipFeatures(loader) {
        const features = ["Wi-Fi"];
        const word3 = await this.readEfuse(loader, 3);
        const chipVerDisBt = word3 & (1 << 1);
        if (chipVerDisBt === 0) {
            features.push(" BT");
        }
        const chipVerDisAppCpu = word3 & (1 << 0);
        if (chipVerDisAppCpu !== 0) {
            features.push(" Single Core");
        }
        else {
            features.push(" Dual Core");
        }
        const chipCpuFreqRated = word3 & (1 << 13);
        if (chipCpuFreqRated !== 0) {
            const chipCpuFreqLow = word3 & (1 << 12);
            if (chipCpuFreqLow !== 0) {
                features.push(" 160MHz");
            }
            else {
                features.push(" 240MHz");
            }
        }
        const pkgVersion = await this.getPkgVersion(loader);
        if ([2, 4, 5, 6].indexOf(pkgVersion) !== -1) {
            features.push(" Embedded Flash");
        }
        if (pkgVersion === 6) {
            features.push(" Embedded PSRAM");
        }
        const word4 = await this.readEfuse(loader, 4);
        const adcVref = (word4 >> 8) & 0x1f;
        if (adcVref !== 0) {
            features.push(" VRef calibration in efuse");
        }
        const blk3PartRes = (word3 >> 14) & 0x1;
        if (blk3PartRes !== 0) {
            features.push(" BLK3 partially reserved");
        }
        const word6 = await this.readEfuse(loader, 6);
        const codingScheme = word6 & 0x3;
        const codingSchemeArr = ["None", "3/4", "Repeat (UNSUPPORTED)", "Invalid"];
        features.push(" Coding Scheme " + codingSchemeArr[codingScheme]);
        return features;
    }
    async getCrystalFreq(loader) {
        const uartDiv = (await loader.readReg(this.UART_CLKDIV_REG)) & this.UART_CLKDIV_MASK;
        const etsXtal = (loader.transport.baudrate * uartDiv) / 1000000 / this.XTAL_CLK_DIVIDER;
        let normXtal;
        if (etsXtal > 33) {
            normXtal = 40;
        }
        else {
            normXtal = 26;
        }
        if (Math.abs(normXtal - etsXtal) > 1) {
            loader.info("WARNING: Unsupported crystal in use");
        }
        return normXtal;
    }
    _d2h(d) {
        const h = (+d).toString(16);
        return h.length === 1 ? "0" + h : h;
    }
    async readMac(loader) {
        let mac0 = await this.readEfuse(loader, 1);
        mac0 = mac0 >>> 0;
        let mac1 = await this.readEfuse(loader, 2);
        mac1 = mac1 >>> 0;
        const mac = new Uint8Array(6);
        mac[0] = (mac1 >> 8) & 0xff;
        mac[1] = mac1 & 0xff;
        mac[2] = (mac0 >> 24) & 0xff;
        mac[3] = (mac0 >> 16) & 0xff;
        mac[4] = (mac0 >> 8) & 0xff;
        mac[5] = mac0 & 0xff;
        return (this._d2h(mac[0]) +
            ":" +
            this._d2h(mac[1]) +
            ":" +
            this._d2h(mac[2]) +
            ":" +
            this._d2h(mac[3]) +
            ":" +
            this._d2h(mac[4]) +
            ":" +
            this._d2h(mac[5]));
    }
}


/***/ }),

/***/ "./node_modules/esptool-js/lib/targets/esp32p4.js":
/*!********************************************************!*\
  !*** ./node_modules/esptool-js/lib/targets/esp32p4.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ESP32P4ROM: () => (/* binding */ ESP32P4ROM)
/* harmony export */ });
/* harmony import */ var _esp32_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./esp32.js */ "./node_modules/esptool-js/lib/targets/esp32.js");

class ESP32P4ROM extends _esp32_js__WEBPACK_IMPORTED_MODULE_0__.ESP32ROM {
    constructor() {
        super(...arguments);
        this.CHIP_NAME = "ESP32-P4";
        this.IMAGE_CHIP_ID = 18;
        this.IROM_MAP_START = 0x40000000;
        this.IROM_MAP_END = 0x4c000000;
        this.DROM_MAP_START = 0x40000000;
        this.DROM_MAP_END = 0x4c000000;
        this.BOOTLOADER_FLASH_OFFSET = 0x2000; // First 2 sectors are reserved for FE purposes
        this.CHIP_DETECT_MAGIC_VALUE = [0x0, 0x0addbad0];
        this.UART_DATE_REG_ADDR = 0x500ca000 + 0x8c;
        this.EFUSE_BASE = 0x5012d000;
        this.EFUSE_BLOCK1_ADDR = this.EFUSE_BASE + 0x044;
        this.MAC_EFUSE_REG = this.EFUSE_BASE + 0x044;
        this.SPI_REG_BASE = 0x5008d000; // SPIMEM1
        this.SPI_USR_OFFS = 0x18;
        this.SPI_USR1_OFFS = 0x1c;
        this.SPI_USR2_OFFS = 0x20;
        this.SPI_MOSI_DLEN_OFFS = 0x24;
        this.SPI_MISO_DLEN_OFFS = 0x28;
        this.SPI_W0_OFFS = 0x58;
        this.EFUSE_RD_REG_BASE = this.EFUSE_BASE + 0x030; // BLOCK0 read base address
        this.EFUSE_PURPOSE_KEY0_REG = this.EFUSE_BASE + 0x34;
        this.EFUSE_PURPOSE_KEY0_SHIFT = 24;
        this.EFUSE_PURPOSE_KEY1_REG = this.EFUSE_BASE + 0x34;
        this.EFUSE_PURPOSE_KEY1_SHIFT = 28;
        this.EFUSE_PURPOSE_KEY2_REG = this.EFUSE_BASE + 0x38;
        this.EFUSE_PURPOSE_KEY2_SHIFT = 0;
        this.EFUSE_PURPOSE_KEY3_REG = this.EFUSE_BASE + 0x38;
        this.EFUSE_PURPOSE_KEY3_SHIFT = 4;
        this.EFUSE_PURPOSE_KEY4_REG = this.EFUSE_BASE + 0x38;
        this.EFUSE_PURPOSE_KEY4_SHIFT = 8;
        this.EFUSE_PURPOSE_KEY5_REG = this.EFUSE_BASE + 0x38;
        this.EFUSE_PURPOSE_KEY5_SHIFT = 12;
        this.EFUSE_DIS_DOWNLOAD_MANUAL_ENCRYPT_REG = this.EFUSE_RD_REG_BASE;
        this.EFUSE_DIS_DOWNLOAD_MANUAL_ENCRYPT = 1 << 20;
        this.EFUSE_SPI_BOOT_CRYPT_CNT_REG = this.EFUSE_BASE + 0x034;
        this.EFUSE_SPI_BOOT_CRYPT_CNT_MASK = 0x7 << 18;
        this.EFUSE_SECURE_BOOT_EN_REG = this.EFUSE_BASE + 0x038;
        this.EFUSE_SECURE_BOOT_EN_MASK = 1 << 20;
        this.PURPOSE_VAL_XTS_AES256_KEY_1 = 2;
        this.PURPOSE_VAL_XTS_AES256_KEY_2 = 3;
        this.PURPOSE_VAL_XTS_AES128_KEY = 4;
        this.SUPPORTS_ENCRYPTED_FLASH = true;
        this.FLASH_ENCRYPTED_WRITE_ALIGN = 16;
        this.MEMORY_MAP = [
            [0x00000000, 0x00010000, "PADDING"],
            [0x40000000, 0x4c000000, "DROM"],
            [0x4ff00000, 0x4ffa0000, "DRAM"],
            [0x4ff00000, 0x4ffa0000, "BYTE_ACCESSIBLE"],
            [0x4fc00000, 0x4fc20000, "DROM_MASK"],
            [0x4fc00000, 0x4fc20000, "IROM_MASK"],
            [0x40000000, 0x4c000000, "IROM"],
            [0x4ff00000, 0x4ffa0000, "IRAM"],
            [0x50108000, 0x50110000, "RTC_IRAM"],
            [0x50108000, 0x50110000, "RTC_DRAM"],
            [0x600fe000, 0x60100000, "MEM_INTERNAL2"],
        ];
        this.UF2_FAMILY_ID = 0x3d308e94;
        this.EFUSE_MAX_KEY = 5;
        this.KEY_PURPOSES = {
            0: "USER/EMPTY",
            1: "ECDSA_KEY",
            2: "XTS_AES_256_KEY_1",
            3: "XTS_AES_256_KEY_2",
            4: "XTS_AES_128_KEY",
            5: "HMAC_DOWN_ALL",
            6: "HMAC_DOWN_JTAG",
            7: "HMAC_DOWN_DIGITAL_SIGNATURE",
            8: "HMAC_UP",
            9: "SECURE_BOOT_DIGEST0",
            10: "SECURE_BOOT_DIGEST1",
            11: "SECURE_BOOT_DIGEST2",
            12: "KM_INIT_KEY",
        };
    }
    async getPkgVersion(loader) {
        const numWord = 2;
        const addr = this.EFUSE_BLOCK1_ADDR + 4 * numWord;
        const registerValue = await loader.readReg(addr);
        return (registerValue >> 27) & 0x07;
    }
    async getMinorChipVersion(loader) {
        const numWord = 2;
        const addr = this.EFUSE_BLOCK1_ADDR + 4 * numWord;
        const registerValue = await loader.readReg(addr);
        return (registerValue >> 0) & 0x0f;
    }
    async getMajorChipVersion(loader) {
        const numWord = 2;
        const addr = this.EFUSE_BLOCK1_ADDR + 4 * numWord;
        const registerValue = await loader.readReg(addr);
        return (registerValue >> 4) & 0x03;
    }
    async getChipDescription(loader) {
        const pkgVersion = await this.getPkgVersion(loader);
        const chipName = pkgVersion === 0 ? "ESP32-P4" : "unknown ESP32-P4";
        const majorRev = await this.getMajorChipVersion(loader);
        const minorRev = await this.getMinorChipVersion(loader);
        return `${chipName} (revision v${majorRev}.${minorRev})`;
    }
    async getChipFeatures(loader) {
        return ["High-Performance MCU"];
    }
    async getCrystalFreq(loader) {
        return 40; // ESP32P4 XTAL is fixed to 40MHz
    }
    async getFlashVoltage(loader) {
        return;
    }
    async overrideVddsdio(loader) {
        loader.debug("VDD_SDIO overrides are not supported for ESP32-P4");
    }
    async readMac(loader) {
        let mac0 = await loader.readReg(this.MAC_EFUSE_REG);
        mac0 = mac0 >>> 0;
        let mac1 = await loader.readReg(this.MAC_EFUSE_REG + 4);
        mac1 = (mac1 >>> 0) & 0x0000ffff;
        const mac = new Uint8Array(6);
        mac[0] = (mac1 >> 8) & 0xff;
        mac[1] = mac1 & 0xff;
        mac[2] = (mac0 >> 24) & 0xff;
        mac[3] = (mac0 >> 16) & 0xff;
        mac[4] = (mac0 >> 8) & 0xff;
        mac[5] = mac0 & 0xff;
        return (this._d2h(mac[0]) +
            ":" +
            this._d2h(mac[1]) +
            ":" +
            this._d2h(mac[2]) +
            ":" +
            this._d2h(mac[3]) +
            ":" +
            this._d2h(mac[4]) +
            ":" +
            this._d2h(mac[5]));
    }
    async getFlashCryptConfig(loader) {
        return; // doesn't exist on ESP32-P4
    }
    async getSecureBootEnabled(laoder) {
        const registerValue = await laoder.readReg(this.EFUSE_SECURE_BOOT_EN_REG);
        return registerValue & this.EFUSE_SECURE_BOOT_EN_MASK;
    }
    async getKeyBlockPurpose(loader, keyBlock) {
        if (keyBlock < 0 || keyBlock > this.EFUSE_MAX_KEY) {
            loader.debug(`Valid key block numbers must be in range 0-${this.EFUSE_MAX_KEY}`);
            return;
        }
        const regShiftDictionary = [
            [this.EFUSE_PURPOSE_KEY0_REG, this.EFUSE_PURPOSE_KEY0_SHIFT],
            [this.EFUSE_PURPOSE_KEY1_REG, this.EFUSE_PURPOSE_KEY1_SHIFT],
            [this.EFUSE_PURPOSE_KEY2_REG, this.EFUSE_PURPOSE_KEY2_SHIFT],
            [this.EFUSE_PURPOSE_KEY3_REG, this.EFUSE_PURPOSE_KEY3_SHIFT],
            [this.EFUSE_PURPOSE_KEY4_REG, this.EFUSE_PURPOSE_KEY4_SHIFT],
            [this.EFUSE_PURPOSE_KEY5_REG, this.EFUSE_PURPOSE_KEY5_SHIFT],
        ];
        const [reg, shift] = regShiftDictionary[keyBlock];
        const registerValue = await loader.readReg(reg);
        return (registerValue >> shift) & 0xf;
    }
    async isFlashEncryptionKeyValid(loader) {
        const purposes = [];
        for (let i = 0; i <= this.EFUSE_MAX_KEY; i++) {
            const purpose = await this.getKeyBlockPurpose(loader, i);
            purposes.push(purpose);
        }
        const isXtsAes128Key = purposes.find((p) => p === this.PURPOSE_VAL_XTS_AES128_KEY);
        if (typeof isXtsAes128Key !== undefined) {
            return true;
        }
        const isXtsAes256Key1 = purposes.find((p) => p === this.PURPOSE_VAL_XTS_AES256_KEY_1);
        const isXtsAes256Key2 = purposes.find((p) => p === this.PURPOSE_VAL_XTS_AES256_KEY_2);
        if (typeof isXtsAes256Key1 !== undefined && typeof isXtsAes256Key2 !== undefined) {
            return true;
        }
        return false;
    }
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfZXNwdG9vbC1qc19saWJfdGFyZ2V0c19lc3AzMnA0X2pzLmJ1bmRsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUErQjtBQUN4Qix1QkFBdUIsd0NBQUc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDeExzQztBQUMvQix5QkFBeUIsK0NBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFVBQVUsYUFBYSxTQUFTLEdBQUcsU0FBUztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsbUJBQW1CO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9UYWN0aWxpdHkgV2ViIEluc3RhbGxlci8uL25vZGVfbW9kdWxlcy9lc3B0b29sLWpzL2xpYi90YXJnZXRzL2VzcDMyLmpzIiwid2VicGFjazovL1RhY3RpbGl0eSBXZWIgSW5zdGFsbGVyLy4vbm9kZV9tb2R1bGVzL2VzcHRvb2wtanMvbGliL3RhcmdldHMvZXNwMzJwNC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBST00gfSBmcm9tIFwiLi9yb20uanNcIjtcbmV4cG9ydCBjbGFzcyBFU1AzMlJPTSBleHRlbmRzIFJPTSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuQ0hJUF9OQU1FID0gXCJFU1AzMlwiO1xuICAgICAgICB0aGlzLklNQUdFX0NISVBfSUQgPSAwO1xuICAgICAgICB0aGlzLkVGVVNFX1JEX1JFR19CQVNFID0gMHgzZmY1YTAwMDtcbiAgICAgICAgdGhpcy5EUl9SRUdfU1lTQ09OX0JBU0UgPSAweDNmZjY2MDAwO1xuICAgICAgICB0aGlzLlVBUlRfQ0xLRElWX1JFRyA9IDB4M2ZmNDAwMTQ7XG4gICAgICAgIHRoaXMuVUFSVF9DTEtESVZfTUFTSyA9IDB4ZmZmZmY7XG4gICAgICAgIHRoaXMuVUFSVF9EQVRFX1JFR19BRERSID0gMHg2MDAwMDA3ODtcbiAgICAgICAgdGhpcy5YVEFMX0NMS19ESVZJREVSID0gMTtcbiAgICAgICAgdGhpcy5GTEFTSF9TSVpFUyA9IHtcbiAgICAgICAgICAgIFwiMU1CXCI6IDB4MDAsXG4gICAgICAgICAgICBcIjJNQlwiOiAweDEwLFxuICAgICAgICAgICAgXCI0TUJcIjogMHgyMCxcbiAgICAgICAgICAgIFwiOE1CXCI6IDB4MzAsXG4gICAgICAgICAgICBcIjE2TUJcIjogMHg0MCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5GTEFTSF9XUklURV9TSVpFID0gMHg0MDA7XG4gICAgICAgIHRoaXMuQk9PVExPQURFUl9GTEFTSF9PRkZTRVQgPSAweDEwMDA7XG4gICAgICAgIHRoaXMuU1BJX1JFR19CQVNFID0gMHgzZmY0MjAwMDtcbiAgICAgICAgdGhpcy5TUElfVVNSX09GRlMgPSAweDFjO1xuICAgICAgICB0aGlzLlNQSV9VU1IxX09GRlMgPSAweDIwO1xuICAgICAgICB0aGlzLlNQSV9VU1IyX09GRlMgPSAweDI0O1xuICAgICAgICB0aGlzLlNQSV9XMF9PRkZTID0gMHg4MDtcbiAgICAgICAgdGhpcy5TUElfTU9TSV9ETEVOX09GRlMgPSAweDI4O1xuICAgICAgICB0aGlzLlNQSV9NSVNPX0RMRU5fT0ZGUyA9IDB4MmM7XG4gICAgfVxuICAgIGFzeW5jIHJlYWRFZnVzZShsb2FkZXIsIG9mZnNldCkge1xuICAgICAgICBjb25zdCBhZGRyID0gdGhpcy5FRlVTRV9SRF9SRUdfQkFTRSArIDQgKiBvZmZzZXQ7XG4gICAgICAgIGxvYWRlci5kZWJ1ZyhcIlJlYWQgZWZ1c2UgXCIgKyBhZGRyKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGxvYWRlci5yZWFkUmVnKGFkZHIpO1xuICAgIH1cbiAgICBhc3luYyBnZXRQa2dWZXJzaW9uKGxvYWRlcikge1xuICAgICAgICBjb25zdCB3b3JkMyA9IGF3YWl0IHRoaXMucmVhZEVmdXNlKGxvYWRlciwgMyk7XG4gICAgICAgIGxldCBwa2dWZXJzaW9uID0gKHdvcmQzID4+IDkpICYgMHgwNztcbiAgICAgICAgcGtnVmVyc2lvbiArPSAoKHdvcmQzID4+IDIpICYgMHgxKSA8PCAzO1xuICAgICAgICByZXR1cm4gcGtnVmVyc2lvbjtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Q2hpcFJldmlzaW9uKGxvYWRlcikge1xuICAgICAgICBjb25zdCB3b3JkMyA9IGF3YWl0IHRoaXMucmVhZEVmdXNlKGxvYWRlciwgMyk7XG4gICAgICAgIGNvbnN0IHdvcmQ1ID0gYXdhaXQgdGhpcy5yZWFkRWZ1c2UobG9hZGVyLCA1KTtcbiAgICAgICAgY29uc3QgYXBiQ3RsRGF0ZSA9IGF3YWl0IGxvYWRlci5yZWFkUmVnKHRoaXMuRFJfUkVHX1NZU0NPTl9CQVNFICsgMHg3Yyk7XG4gICAgICAgIGNvbnN0IHJldkJpdDAgPSAod29yZDMgPj4gMTUpICYgMHgxO1xuICAgICAgICBjb25zdCByZXZCaXQxID0gKHdvcmQ1ID4+IDIwKSAmIDB4MTtcbiAgICAgICAgY29uc3QgcmV2Qml0MiA9IChhcGJDdGxEYXRlID4+IDMxKSAmIDB4MTtcbiAgICAgICAgaWYgKHJldkJpdDAgIT0gMCkge1xuICAgICAgICAgICAgaWYgKHJldkJpdDEgIT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXZCaXQyICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Q2hpcERlc2NyaXB0aW9uKGxvYWRlcikge1xuICAgICAgICBjb25zdCBjaGlwRGVzYyA9IFtcbiAgICAgICAgICAgIFwiRVNQMzItRDBXRFE2XCIsXG4gICAgICAgICAgICBcIkVTUDMyLUQwV0RcIixcbiAgICAgICAgICAgIFwiRVNQMzItRDJXRFwiLFxuICAgICAgICAgICAgXCJcIixcbiAgICAgICAgICAgIFwiRVNQMzItVTRXREhcIixcbiAgICAgICAgICAgIFwiRVNQMzItUElDTy1ENFwiLFxuICAgICAgICAgICAgXCJFU1AzMi1QSUNPLVYzLTAyXCIsXG4gICAgICAgIF07XG4gICAgICAgIGxldCBjaGlwTmFtZSA9IFwiXCI7XG4gICAgICAgIGNvbnN0IHBrZ1ZlcnNpb24gPSBhd2FpdCB0aGlzLmdldFBrZ1ZlcnNpb24obG9hZGVyKTtcbiAgICAgICAgY29uc3QgY2hpcFJldmlzaW9uID0gYXdhaXQgdGhpcy5nZXRDaGlwUmV2aXNpb24obG9hZGVyKTtcbiAgICAgICAgY29uc3QgcmV2MyA9IGNoaXBSZXZpc2lvbiA9PSAzO1xuICAgICAgICBjb25zdCBzaW5nbGVfY29yZSA9IChhd2FpdCB0aGlzLnJlYWRFZnVzZShsb2FkZXIsIDMpKSAmICgxIDw8IDApO1xuICAgICAgICBpZiAoc2luZ2xlX2NvcmUgIT0gMCkge1xuICAgICAgICAgICAgY2hpcERlc2NbMF0gPSBcIkVTUDMyLVMwV0RRNlwiO1xuICAgICAgICAgICAgY2hpcERlc2NbMV0gPSBcIkVTUDMyLVMwV0RcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmV2Mykge1xuICAgICAgICAgICAgY2hpcERlc2NbNV0gPSBcIkVTUDMyLVBJQ08tVjNcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGtnVmVyc2lvbiA+PSAwICYmIHBrZ1ZlcnNpb24gPD0gNikge1xuICAgICAgICAgICAgY2hpcE5hbWUgPSBjaGlwRGVzY1twa2dWZXJzaW9uXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNoaXBOYW1lID0gXCJVbmtub3duIEVTUDMyXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJldjMgJiYgKHBrZ1ZlcnNpb24gPT09IDAgfHwgcGtnVmVyc2lvbiA9PT0gMSkpIHtcbiAgICAgICAgICAgIGNoaXBOYW1lICs9IFwiLVYzXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoaXBOYW1lICsgXCIgKHJldmlzaW9uIFwiICsgY2hpcFJldmlzaW9uICsgXCIpXCI7XG4gICAgfVxuICAgIGFzeW5jIGdldENoaXBGZWF0dXJlcyhsb2FkZXIpIHtcbiAgICAgICAgY29uc3QgZmVhdHVyZXMgPSBbXCJXaS1GaVwiXTtcbiAgICAgICAgY29uc3Qgd29yZDMgPSBhd2FpdCB0aGlzLnJlYWRFZnVzZShsb2FkZXIsIDMpO1xuICAgICAgICBjb25zdCBjaGlwVmVyRGlzQnQgPSB3b3JkMyAmICgxIDw8IDEpO1xuICAgICAgICBpZiAoY2hpcFZlckRpc0J0ID09PSAwKSB7XG4gICAgICAgICAgICBmZWF0dXJlcy5wdXNoKFwiIEJUXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoaXBWZXJEaXNBcHBDcHUgPSB3b3JkMyAmICgxIDw8IDApO1xuICAgICAgICBpZiAoY2hpcFZlckRpc0FwcENwdSAhPT0gMCkge1xuICAgICAgICAgICAgZmVhdHVyZXMucHVzaChcIiBTaW5nbGUgQ29yZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZlYXR1cmVzLnB1c2goXCIgRHVhbCBDb3JlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoaXBDcHVGcmVxUmF0ZWQgPSB3b3JkMyAmICgxIDw8IDEzKTtcbiAgICAgICAgaWYgKGNoaXBDcHVGcmVxUmF0ZWQgIT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaXBDcHVGcmVxTG93ID0gd29yZDMgJiAoMSA8PCAxMik7XG4gICAgICAgICAgICBpZiAoY2hpcENwdUZyZXFMb3cgIT09IDApIHtcbiAgICAgICAgICAgICAgICBmZWF0dXJlcy5wdXNoKFwiIDE2ME1IelwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZlYXR1cmVzLnB1c2goXCIgMjQwTUh6XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBrZ1ZlcnNpb24gPSBhd2FpdCB0aGlzLmdldFBrZ1ZlcnNpb24obG9hZGVyKTtcbiAgICAgICAgaWYgKFsyLCA0LCA1LCA2XS5pbmRleE9mKHBrZ1ZlcnNpb24pICE9PSAtMSkge1xuICAgICAgICAgICAgZmVhdHVyZXMucHVzaChcIiBFbWJlZGRlZCBGbGFzaFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGtnVmVyc2lvbiA9PT0gNikge1xuICAgICAgICAgICAgZmVhdHVyZXMucHVzaChcIiBFbWJlZGRlZCBQU1JBTVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3b3JkNCA9IGF3YWl0IHRoaXMucmVhZEVmdXNlKGxvYWRlciwgNCk7XG4gICAgICAgIGNvbnN0IGFkY1ZyZWYgPSAod29yZDQgPj4gOCkgJiAweDFmO1xuICAgICAgICBpZiAoYWRjVnJlZiAhPT0gMCkge1xuICAgICAgICAgICAgZmVhdHVyZXMucHVzaChcIiBWUmVmIGNhbGlicmF0aW9uIGluIGVmdXNlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsazNQYXJ0UmVzID0gKHdvcmQzID4+IDE0KSAmIDB4MTtcbiAgICAgICAgaWYgKGJsazNQYXJ0UmVzICE9PSAwKSB7XG4gICAgICAgICAgICBmZWF0dXJlcy5wdXNoKFwiIEJMSzMgcGFydGlhbGx5IHJlc2VydmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdvcmQ2ID0gYXdhaXQgdGhpcy5yZWFkRWZ1c2UobG9hZGVyLCA2KTtcbiAgICAgICAgY29uc3QgY29kaW5nU2NoZW1lID0gd29yZDYgJiAweDM7XG4gICAgICAgIGNvbnN0IGNvZGluZ1NjaGVtZUFyciA9IFtcIk5vbmVcIiwgXCIzLzRcIiwgXCJSZXBlYXQgKFVOU1VQUE9SVEVEKVwiLCBcIkludmFsaWRcIl07XG4gICAgICAgIGZlYXR1cmVzLnB1c2goXCIgQ29kaW5nIFNjaGVtZSBcIiArIGNvZGluZ1NjaGVtZUFycltjb2RpbmdTY2hlbWVdKTtcbiAgICAgICAgcmV0dXJuIGZlYXR1cmVzO1xuICAgIH1cbiAgICBhc3luYyBnZXRDcnlzdGFsRnJlcShsb2FkZXIpIHtcbiAgICAgICAgY29uc3QgdWFydERpdiA9IChhd2FpdCBsb2FkZXIucmVhZFJlZyh0aGlzLlVBUlRfQ0xLRElWX1JFRykpICYgdGhpcy5VQVJUX0NMS0RJVl9NQVNLO1xuICAgICAgICBjb25zdCBldHNYdGFsID0gKGxvYWRlci50cmFuc3BvcnQuYmF1ZHJhdGUgKiB1YXJ0RGl2KSAvIDEwMDAwMDAgLyB0aGlzLlhUQUxfQ0xLX0RJVklERVI7XG4gICAgICAgIGxldCBub3JtWHRhbDtcbiAgICAgICAgaWYgKGV0c1h0YWwgPiAzMykge1xuICAgICAgICAgICAgbm9ybVh0YWwgPSA0MDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vcm1YdGFsID0gMjY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE1hdGguYWJzKG5vcm1YdGFsIC0gZXRzWHRhbCkgPiAxKSB7XG4gICAgICAgICAgICBsb2FkZXIuaW5mbyhcIldBUk5JTkc6IFVuc3VwcG9ydGVkIGNyeXN0YWwgaW4gdXNlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub3JtWHRhbDtcbiAgICB9XG4gICAgX2QyaChkKSB7XG4gICAgICAgIGNvbnN0IGggPSAoK2QpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgcmV0dXJuIGgubGVuZ3RoID09PSAxID8gXCIwXCIgKyBoIDogaDtcbiAgICB9XG4gICAgYXN5bmMgcmVhZE1hYyhsb2FkZXIpIHtcbiAgICAgICAgbGV0IG1hYzAgPSBhd2FpdCB0aGlzLnJlYWRFZnVzZShsb2FkZXIsIDEpO1xuICAgICAgICBtYWMwID0gbWFjMCA+Pj4gMDtcbiAgICAgICAgbGV0IG1hYzEgPSBhd2FpdCB0aGlzLnJlYWRFZnVzZShsb2FkZXIsIDIpO1xuICAgICAgICBtYWMxID0gbWFjMSA+Pj4gMDtcbiAgICAgICAgY29uc3QgbWFjID0gbmV3IFVpbnQ4QXJyYXkoNik7XG4gICAgICAgIG1hY1swXSA9IChtYWMxID4+IDgpICYgMHhmZjtcbiAgICAgICAgbWFjWzFdID0gbWFjMSAmIDB4ZmY7XG4gICAgICAgIG1hY1syXSA9IChtYWMwID4+IDI0KSAmIDB4ZmY7XG4gICAgICAgIG1hY1szXSA9IChtYWMwID4+IDE2KSAmIDB4ZmY7XG4gICAgICAgIG1hY1s0XSA9IChtYWMwID4+IDgpICYgMHhmZjtcbiAgICAgICAgbWFjWzVdID0gbWFjMCAmIDB4ZmY7XG4gICAgICAgIHJldHVybiAodGhpcy5fZDJoKG1hY1swXSkgK1xuICAgICAgICAgICAgXCI6XCIgK1xuICAgICAgICAgICAgdGhpcy5fZDJoKG1hY1sxXSkgK1xuICAgICAgICAgICAgXCI6XCIgK1xuICAgICAgICAgICAgdGhpcy5fZDJoKG1hY1syXSkgK1xuICAgICAgICAgICAgXCI6XCIgK1xuICAgICAgICAgICAgdGhpcy5fZDJoKG1hY1szXSkgK1xuICAgICAgICAgICAgXCI6XCIgK1xuICAgICAgICAgICAgdGhpcy5fZDJoKG1hY1s0XSkgK1xuICAgICAgICAgICAgXCI6XCIgK1xuICAgICAgICAgICAgdGhpcy5fZDJoKG1hY1s1XSkpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IEVTUDMyUk9NIH0gZnJvbSBcIi4vZXNwMzIuanNcIjtcbmV4cG9ydCBjbGFzcyBFU1AzMlA0Uk9NIGV4dGVuZHMgRVNQMzJST00ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLkNISVBfTkFNRSA9IFwiRVNQMzItUDRcIjtcbiAgICAgICAgdGhpcy5JTUFHRV9DSElQX0lEID0gMTg7XG4gICAgICAgIHRoaXMuSVJPTV9NQVBfU1RBUlQgPSAweDQwMDAwMDAwO1xuICAgICAgICB0aGlzLklST01fTUFQX0VORCA9IDB4NGMwMDAwMDA7XG4gICAgICAgIHRoaXMuRFJPTV9NQVBfU1RBUlQgPSAweDQwMDAwMDAwO1xuICAgICAgICB0aGlzLkRST01fTUFQX0VORCA9IDB4NGMwMDAwMDA7XG4gICAgICAgIHRoaXMuQk9PVExPQURFUl9GTEFTSF9PRkZTRVQgPSAweDIwMDA7IC8vIEZpcnN0IDIgc2VjdG9ycyBhcmUgcmVzZXJ2ZWQgZm9yIEZFIHB1cnBvc2VzXG4gICAgICAgIHRoaXMuQ0hJUF9ERVRFQ1RfTUFHSUNfVkFMVUUgPSBbMHgwLCAweDBhZGRiYWQwXTtcbiAgICAgICAgdGhpcy5VQVJUX0RBVEVfUkVHX0FERFIgPSAweDUwMGNhMDAwICsgMHg4YztcbiAgICAgICAgdGhpcy5FRlVTRV9CQVNFID0gMHg1MDEyZDAwMDtcbiAgICAgICAgdGhpcy5FRlVTRV9CTE9DSzFfQUREUiA9IHRoaXMuRUZVU0VfQkFTRSArIDB4MDQ0O1xuICAgICAgICB0aGlzLk1BQ19FRlVTRV9SRUcgPSB0aGlzLkVGVVNFX0JBU0UgKyAweDA0NDtcbiAgICAgICAgdGhpcy5TUElfUkVHX0JBU0UgPSAweDUwMDhkMDAwOyAvLyBTUElNRU0xXG4gICAgICAgIHRoaXMuU1BJX1VTUl9PRkZTID0gMHgxODtcbiAgICAgICAgdGhpcy5TUElfVVNSMV9PRkZTID0gMHgxYztcbiAgICAgICAgdGhpcy5TUElfVVNSMl9PRkZTID0gMHgyMDtcbiAgICAgICAgdGhpcy5TUElfTU9TSV9ETEVOX09GRlMgPSAweDI0O1xuICAgICAgICB0aGlzLlNQSV9NSVNPX0RMRU5fT0ZGUyA9IDB4Mjg7XG4gICAgICAgIHRoaXMuU1BJX1cwX09GRlMgPSAweDU4O1xuICAgICAgICB0aGlzLkVGVVNFX1JEX1JFR19CQVNFID0gdGhpcy5FRlVTRV9CQVNFICsgMHgwMzA7IC8vIEJMT0NLMCByZWFkIGJhc2UgYWRkcmVzc1xuICAgICAgICB0aGlzLkVGVVNFX1BVUlBPU0VfS0VZMF9SRUcgPSB0aGlzLkVGVVNFX0JBU0UgKyAweDM0O1xuICAgICAgICB0aGlzLkVGVVNFX1BVUlBPU0VfS0VZMF9TSElGVCA9IDI0O1xuICAgICAgICB0aGlzLkVGVVNFX1BVUlBPU0VfS0VZMV9SRUcgPSB0aGlzLkVGVVNFX0JBU0UgKyAweDM0O1xuICAgICAgICB0aGlzLkVGVVNFX1BVUlBPU0VfS0VZMV9TSElGVCA9IDI4O1xuICAgICAgICB0aGlzLkVGVVNFX1BVUlBPU0VfS0VZMl9SRUcgPSB0aGlzLkVGVVNFX0JBU0UgKyAweDM4O1xuICAgICAgICB0aGlzLkVGVVNFX1BVUlBPU0VfS0VZMl9TSElGVCA9IDA7XG4gICAgICAgIHRoaXMuRUZVU0VfUFVSUE9TRV9LRVkzX1JFRyA9IHRoaXMuRUZVU0VfQkFTRSArIDB4Mzg7XG4gICAgICAgIHRoaXMuRUZVU0VfUFVSUE9TRV9LRVkzX1NISUZUID0gNDtcbiAgICAgICAgdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTRfUkVHID0gdGhpcy5FRlVTRV9CQVNFICsgMHgzODtcbiAgICAgICAgdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTRfU0hJRlQgPSA4O1xuICAgICAgICB0aGlzLkVGVVNFX1BVUlBPU0VfS0VZNV9SRUcgPSB0aGlzLkVGVVNFX0JBU0UgKyAweDM4O1xuICAgICAgICB0aGlzLkVGVVNFX1BVUlBPU0VfS0VZNV9TSElGVCA9IDEyO1xuICAgICAgICB0aGlzLkVGVVNFX0RJU19ET1dOTE9BRF9NQU5VQUxfRU5DUllQVF9SRUcgPSB0aGlzLkVGVVNFX1JEX1JFR19CQVNFO1xuICAgICAgICB0aGlzLkVGVVNFX0RJU19ET1dOTE9BRF9NQU5VQUxfRU5DUllQVCA9IDEgPDwgMjA7XG4gICAgICAgIHRoaXMuRUZVU0VfU1BJX0JPT1RfQ1JZUFRfQ05UX1JFRyA9IHRoaXMuRUZVU0VfQkFTRSArIDB4MDM0O1xuICAgICAgICB0aGlzLkVGVVNFX1NQSV9CT09UX0NSWVBUX0NOVF9NQVNLID0gMHg3IDw8IDE4O1xuICAgICAgICB0aGlzLkVGVVNFX1NFQ1VSRV9CT09UX0VOX1JFRyA9IHRoaXMuRUZVU0VfQkFTRSArIDB4MDM4O1xuICAgICAgICB0aGlzLkVGVVNFX1NFQ1VSRV9CT09UX0VOX01BU0sgPSAxIDw8IDIwO1xuICAgICAgICB0aGlzLlBVUlBPU0VfVkFMX1hUU19BRVMyNTZfS0VZXzEgPSAyO1xuICAgICAgICB0aGlzLlBVUlBPU0VfVkFMX1hUU19BRVMyNTZfS0VZXzIgPSAzO1xuICAgICAgICB0aGlzLlBVUlBPU0VfVkFMX1hUU19BRVMxMjhfS0VZID0gNDtcbiAgICAgICAgdGhpcy5TVVBQT1JUU19FTkNSWVBURURfRkxBU0ggPSB0cnVlO1xuICAgICAgICB0aGlzLkZMQVNIX0VOQ1JZUFRFRF9XUklURV9BTElHTiA9IDE2O1xuICAgICAgICB0aGlzLk1FTU9SWV9NQVAgPSBbXG4gICAgICAgICAgICBbMHgwMDAwMDAwMCwgMHgwMDAxMDAwMCwgXCJQQURESU5HXCJdLFxuICAgICAgICAgICAgWzB4NDAwMDAwMDAsIDB4NGMwMDAwMDAsIFwiRFJPTVwiXSxcbiAgICAgICAgICAgIFsweDRmZjAwMDAwLCAweDRmZmEwMDAwLCBcIkRSQU1cIl0sXG4gICAgICAgICAgICBbMHg0ZmYwMDAwMCwgMHg0ZmZhMDAwMCwgXCJCWVRFX0FDQ0VTU0lCTEVcIl0sXG4gICAgICAgICAgICBbMHg0ZmMwMDAwMCwgMHg0ZmMyMDAwMCwgXCJEUk9NX01BU0tcIl0sXG4gICAgICAgICAgICBbMHg0ZmMwMDAwMCwgMHg0ZmMyMDAwMCwgXCJJUk9NX01BU0tcIl0sXG4gICAgICAgICAgICBbMHg0MDAwMDAwMCwgMHg0YzAwMDAwMCwgXCJJUk9NXCJdLFxuICAgICAgICAgICAgWzB4NGZmMDAwMDAsIDB4NGZmYTAwMDAsIFwiSVJBTVwiXSxcbiAgICAgICAgICAgIFsweDUwMTA4MDAwLCAweDUwMTEwMDAwLCBcIlJUQ19JUkFNXCJdLFxuICAgICAgICAgICAgWzB4NTAxMDgwMDAsIDB4NTAxMTAwMDAsIFwiUlRDX0RSQU1cIl0sXG4gICAgICAgICAgICBbMHg2MDBmZTAwMCwgMHg2MDEwMDAwMCwgXCJNRU1fSU5URVJOQUwyXCJdLFxuICAgICAgICBdO1xuICAgICAgICB0aGlzLlVGMl9GQU1JTFlfSUQgPSAweDNkMzA4ZTk0O1xuICAgICAgICB0aGlzLkVGVVNFX01BWF9LRVkgPSA1O1xuICAgICAgICB0aGlzLktFWV9QVVJQT1NFUyA9IHtcbiAgICAgICAgICAgIDA6IFwiVVNFUi9FTVBUWVwiLFxuICAgICAgICAgICAgMTogXCJFQ0RTQV9LRVlcIixcbiAgICAgICAgICAgIDI6IFwiWFRTX0FFU18yNTZfS0VZXzFcIixcbiAgICAgICAgICAgIDM6IFwiWFRTX0FFU18yNTZfS0VZXzJcIixcbiAgICAgICAgICAgIDQ6IFwiWFRTX0FFU18xMjhfS0VZXCIsXG4gICAgICAgICAgICA1OiBcIkhNQUNfRE9XTl9BTExcIixcbiAgICAgICAgICAgIDY6IFwiSE1BQ19ET1dOX0pUQUdcIixcbiAgICAgICAgICAgIDc6IFwiSE1BQ19ET1dOX0RJR0lUQUxfU0lHTkFUVVJFXCIsXG4gICAgICAgICAgICA4OiBcIkhNQUNfVVBcIixcbiAgICAgICAgICAgIDk6IFwiU0VDVVJFX0JPT1RfRElHRVNUMFwiLFxuICAgICAgICAgICAgMTA6IFwiU0VDVVJFX0JPT1RfRElHRVNUMVwiLFxuICAgICAgICAgICAgMTE6IFwiU0VDVVJFX0JPT1RfRElHRVNUMlwiLFxuICAgICAgICAgICAgMTI6IFwiS01fSU5JVF9LRVlcIixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UGtnVmVyc2lvbihsb2FkZXIpIHtcbiAgICAgICAgY29uc3QgbnVtV29yZCA9IDI7XG4gICAgICAgIGNvbnN0IGFkZHIgPSB0aGlzLkVGVVNFX0JMT0NLMV9BRERSICsgNCAqIG51bVdvcmQ7XG4gICAgICAgIGNvbnN0IHJlZ2lzdGVyVmFsdWUgPSBhd2FpdCBsb2FkZXIucmVhZFJlZyhhZGRyKTtcbiAgICAgICAgcmV0dXJuIChyZWdpc3RlclZhbHVlID4+IDI3KSAmIDB4MDc7XG4gICAgfVxuICAgIGFzeW5jIGdldE1pbm9yQ2hpcFZlcnNpb24obG9hZGVyKSB7XG4gICAgICAgIGNvbnN0IG51bVdvcmQgPSAyO1xuICAgICAgICBjb25zdCBhZGRyID0gdGhpcy5FRlVTRV9CTE9DSzFfQUREUiArIDQgKiBudW1Xb3JkO1xuICAgICAgICBjb25zdCByZWdpc3RlclZhbHVlID0gYXdhaXQgbG9hZGVyLnJlYWRSZWcoYWRkcik7XG4gICAgICAgIHJldHVybiAocmVnaXN0ZXJWYWx1ZSA+PiAwKSAmIDB4MGY7XG4gICAgfVxuICAgIGFzeW5jIGdldE1ham9yQ2hpcFZlcnNpb24obG9hZGVyKSB7XG4gICAgICAgIGNvbnN0IG51bVdvcmQgPSAyO1xuICAgICAgICBjb25zdCBhZGRyID0gdGhpcy5FRlVTRV9CTE9DSzFfQUREUiArIDQgKiBudW1Xb3JkO1xuICAgICAgICBjb25zdCByZWdpc3RlclZhbHVlID0gYXdhaXQgbG9hZGVyLnJlYWRSZWcoYWRkcik7XG4gICAgICAgIHJldHVybiAocmVnaXN0ZXJWYWx1ZSA+PiA0KSAmIDB4MDM7XG4gICAgfVxuICAgIGFzeW5jIGdldENoaXBEZXNjcmlwdGlvbihsb2FkZXIpIHtcbiAgICAgICAgY29uc3QgcGtnVmVyc2lvbiA9IGF3YWl0IHRoaXMuZ2V0UGtnVmVyc2lvbihsb2FkZXIpO1xuICAgICAgICBjb25zdCBjaGlwTmFtZSA9IHBrZ1ZlcnNpb24gPT09IDAgPyBcIkVTUDMyLVA0XCIgOiBcInVua25vd24gRVNQMzItUDRcIjtcbiAgICAgICAgY29uc3QgbWFqb3JSZXYgPSBhd2FpdCB0aGlzLmdldE1ham9yQ2hpcFZlcnNpb24obG9hZGVyKTtcbiAgICAgICAgY29uc3QgbWlub3JSZXYgPSBhd2FpdCB0aGlzLmdldE1pbm9yQ2hpcFZlcnNpb24obG9hZGVyKTtcbiAgICAgICAgcmV0dXJuIGAke2NoaXBOYW1lfSAocmV2aXNpb24gdiR7bWFqb3JSZXZ9LiR7bWlub3JSZXZ9KWA7XG4gICAgfVxuICAgIGFzeW5jIGdldENoaXBGZWF0dXJlcyhsb2FkZXIpIHtcbiAgICAgICAgcmV0dXJuIFtcIkhpZ2gtUGVyZm9ybWFuY2UgTUNVXCJdO1xuICAgIH1cbiAgICBhc3luYyBnZXRDcnlzdGFsRnJlcShsb2FkZXIpIHtcbiAgICAgICAgcmV0dXJuIDQwOyAvLyBFU1AzMlA0IFhUQUwgaXMgZml4ZWQgdG8gNDBNSHpcbiAgICB9XG4gICAgYXN5bmMgZ2V0Rmxhc2hWb2x0YWdlKGxvYWRlcikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGFzeW5jIG92ZXJyaWRlVmRkc2Rpbyhsb2FkZXIpIHtcbiAgICAgICAgbG9hZGVyLmRlYnVnKFwiVkREX1NESU8gb3ZlcnJpZGVzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBFU1AzMi1QNFwiKTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZE1hYyhsb2FkZXIpIHtcbiAgICAgICAgbGV0IG1hYzAgPSBhd2FpdCBsb2FkZXIucmVhZFJlZyh0aGlzLk1BQ19FRlVTRV9SRUcpO1xuICAgICAgICBtYWMwID0gbWFjMCA+Pj4gMDtcbiAgICAgICAgbGV0IG1hYzEgPSBhd2FpdCBsb2FkZXIucmVhZFJlZyh0aGlzLk1BQ19FRlVTRV9SRUcgKyA0KTtcbiAgICAgICAgbWFjMSA9IChtYWMxID4+PiAwKSAmIDB4MDAwMGZmZmY7XG4gICAgICAgIGNvbnN0IG1hYyA9IG5ldyBVaW50OEFycmF5KDYpO1xuICAgICAgICBtYWNbMF0gPSAobWFjMSA+PiA4KSAmIDB4ZmY7XG4gICAgICAgIG1hY1sxXSA9IG1hYzEgJiAweGZmO1xuICAgICAgICBtYWNbMl0gPSAobWFjMCA+PiAyNCkgJiAweGZmO1xuICAgICAgICBtYWNbM10gPSAobWFjMCA+PiAxNikgJiAweGZmO1xuICAgICAgICBtYWNbNF0gPSAobWFjMCA+PiA4KSAmIDB4ZmY7XG4gICAgICAgIG1hY1s1XSA9IG1hYzAgJiAweGZmO1xuICAgICAgICByZXR1cm4gKHRoaXMuX2QyaChtYWNbMF0pICtcbiAgICAgICAgICAgIFwiOlwiICtcbiAgICAgICAgICAgIHRoaXMuX2QyaChtYWNbMV0pICtcbiAgICAgICAgICAgIFwiOlwiICtcbiAgICAgICAgICAgIHRoaXMuX2QyaChtYWNbMl0pICtcbiAgICAgICAgICAgIFwiOlwiICtcbiAgICAgICAgICAgIHRoaXMuX2QyaChtYWNbM10pICtcbiAgICAgICAgICAgIFwiOlwiICtcbiAgICAgICAgICAgIHRoaXMuX2QyaChtYWNbNF0pICtcbiAgICAgICAgICAgIFwiOlwiICtcbiAgICAgICAgICAgIHRoaXMuX2QyaChtYWNbNV0pKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Rmxhc2hDcnlwdENvbmZpZyhsb2FkZXIpIHtcbiAgICAgICAgcmV0dXJuOyAvLyBkb2Vzbid0IGV4aXN0IG9uIEVTUDMyLVA0XG4gICAgfVxuICAgIGFzeW5jIGdldFNlY3VyZUJvb3RFbmFibGVkKGxhb2Rlcikge1xuICAgICAgICBjb25zdCByZWdpc3RlclZhbHVlID0gYXdhaXQgbGFvZGVyLnJlYWRSZWcodGhpcy5FRlVTRV9TRUNVUkVfQk9PVF9FTl9SRUcpO1xuICAgICAgICByZXR1cm4gcmVnaXN0ZXJWYWx1ZSAmIHRoaXMuRUZVU0VfU0VDVVJFX0JPT1RfRU5fTUFTSztcbiAgICB9XG4gICAgYXN5bmMgZ2V0S2V5QmxvY2tQdXJwb3NlKGxvYWRlciwga2V5QmxvY2spIHtcbiAgICAgICAgaWYgKGtleUJsb2NrIDwgMCB8fCBrZXlCbG9jayA+IHRoaXMuRUZVU0VfTUFYX0tFWSkge1xuICAgICAgICAgICAgbG9hZGVyLmRlYnVnKGBWYWxpZCBrZXkgYmxvY2sgbnVtYmVycyBtdXN0IGJlIGluIHJhbmdlIDAtJHt0aGlzLkVGVVNFX01BWF9LRVl9YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVnU2hpZnREaWN0aW9uYXJ5ID0gW1xuICAgICAgICAgICAgW3RoaXMuRUZVU0VfUFVSUE9TRV9LRVkwX1JFRywgdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTBfU0hJRlRdLFxuICAgICAgICAgICAgW3RoaXMuRUZVU0VfUFVSUE9TRV9LRVkxX1JFRywgdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTFfU0hJRlRdLFxuICAgICAgICAgICAgW3RoaXMuRUZVU0VfUFVSUE9TRV9LRVkyX1JFRywgdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTJfU0hJRlRdLFxuICAgICAgICAgICAgW3RoaXMuRUZVU0VfUFVSUE9TRV9LRVkzX1JFRywgdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTNfU0hJRlRdLFxuICAgICAgICAgICAgW3RoaXMuRUZVU0VfUFVSUE9TRV9LRVk0X1JFRywgdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTRfU0hJRlRdLFxuICAgICAgICAgICAgW3RoaXMuRUZVU0VfUFVSUE9TRV9LRVk1X1JFRywgdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTVfU0hJRlRdLFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBbcmVnLCBzaGlmdF0gPSByZWdTaGlmdERpY3Rpb25hcnlba2V5QmxvY2tdO1xuICAgICAgICBjb25zdCByZWdpc3RlclZhbHVlID0gYXdhaXQgbG9hZGVyLnJlYWRSZWcocmVnKTtcbiAgICAgICAgcmV0dXJuIChyZWdpc3RlclZhbHVlID4+IHNoaWZ0KSAmIDB4ZjtcbiAgICB9XG4gICAgYXN5bmMgaXNGbGFzaEVuY3J5cHRpb25LZXlWYWxpZChsb2FkZXIpIHtcbiAgICAgICAgY29uc3QgcHVycG9zZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gdGhpcy5FRlVTRV9NQVhfS0VZOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHB1cnBvc2UgPSBhd2FpdCB0aGlzLmdldEtleUJsb2NrUHVycG9zZShsb2FkZXIsIGkpO1xuICAgICAgICAgICAgcHVycG9zZXMucHVzaChwdXJwb3NlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc1h0c0FlczEyOEtleSA9IHB1cnBvc2VzLmZpbmQoKHApID0+IHAgPT09IHRoaXMuUFVSUE9TRV9WQUxfWFRTX0FFUzEyOF9LRVkpO1xuICAgICAgICBpZiAodHlwZW9mIGlzWHRzQWVzMTI4S2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzWHRzQWVzMjU2S2V5MSA9IHB1cnBvc2VzLmZpbmQoKHApID0+IHAgPT09IHRoaXMuUFVSUE9TRV9WQUxfWFRTX0FFUzI1Nl9LRVlfMSk7XG4gICAgICAgIGNvbnN0IGlzWHRzQWVzMjU2S2V5MiA9IHB1cnBvc2VzLmZpbmQoKHApID0+IHAgPT09IHRoaXMuUFVSUE9TRV9WQUxfWFRTX0FFUzI1Nl9LRVlfMik7XG4gICAgICAgIGlmICh0eXBlb2YgaXNYdHNBZXMyNTZLZXkxICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGlzWHRzQWVzMjU2S2V5MiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9